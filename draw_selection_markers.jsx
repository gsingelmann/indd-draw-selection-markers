if ( app.selection.length ) app.doScript( main, undefined, undefined, UndoModes.ENTIRE_SCRIPT, "Textrahmen auslinieren");function main() {  var doc = app.activeDocument;  var sel = app.selection;  // ---------------------------------------------------------------------------------------  //  Bei Spread-Linealen muss man nicht drauf achten, auf welcher Seite das Ding liegt  // ---------------------------------------------------------------------------------------  var prev_ro = doc.viewPreferences.rulerOrigin;  doc.viewPreferences.rulerOrigin = RulerOrigin.SPREAD_ORIGIN;  // ---------------------------------------------------------------------------------------  //  Eine eigene Farbe für den gezeichneten Rahmen  // ---------------------------------------------------------------------------------------  var frame_color = doc.colors.item("frame_color");  if ( !frame_color.isValid ) {    frame_color = doc.colors.add({name: "frame_color"});    frame_color.space = ColorSpace.RGB;    frame_color.colorValue = [ 80, 150, 255 ];  }  // ---------------------------------------------------------------------------------------  //  Es kann ja mehr als ein Textrahmen markiert sein  // ---------------------------------------------------------------------------------------  for ( var ns = 0; ns < sel.length; ns++ ) {    // ---------------------------------------------------------------------------------------    //  Es soll auch mit Rahmen auf der Montagefläche funzen    // ---------------------------------------------------------------------------------------    var pg = sel[ns].parentPage;    if ( ! pg ) {      pg = sel[ns];      do {        pg = pg.parent;      } while ( pg.constructor.name != "Spread" && pg.constructor.name != "MasterSpread" );    }    // ---------------------------------------------------------------------------------------    //  Erst mal alle Rechtecke anlegen und in Arrays ablegen    // ---------------------------------------------------------------------------------------    var gb = sel[ns].geometricBounds;    var items = [];    if ( sel[ns].contentType == ContentType.GRAPHIC_TYPE ) {       items.push( pg.graphicLines.add() );       items[ items.length-1 ].paths[0].entirePath = [ [ gb[1], gb[0] ], [ gb[3], gb[2] ] ];       items[ items.length-1 ].strokeColor = frame_color;       items[ items.length-1 ].strokeWeight = .25;       items.push( pg.graphicLines.add() );       items[ items.length-1 ].paths[0].entirePath = [ [ gb[1], gb[2] ], [ gb[3], gb[0] ] ];       items[ items.length-1 ].strokeColor = frame_color;       items[ items.length-1 ].strokeWeight = .25;     }        items.push( draw_rect( pg, -1, -1, gb, 1, false ) )    items.push( draw_rect( pg, 0, 0, gb, 1 ) )    items.push( draw_rect( pg, 0.5, 0, gb, 1 ) )    items.push( draw_rect( pg, 1, 0, gb, 1 ) )    items.push( draw_rect( pg, 1, 0.5, gb, 1 ) )    items.push( draw_rect( pg, 1, 1, gb, 1 ) )    items.push( draw_rect( pg, 0.5, 1, gb, 1 ) )    items.push( draw_rect( pg, 0, 1, gb, 1 ) )    items.push( draw_rect( pg, 0, 0.5, gb, 1 ) )        if ( sel[ns].constructor.name == "TextFrame" ) {      items.push( draw_rect( pg, 0, 0.11, gb, 1.4 ) )      items.push( draw_rect( pg, 1, 0.89, gb, 1.4 ) )      $.writeln( sel[ns].previousTextFrame );      if ( sel[ns].previousTextFrame  ) {        items.push( draw_rect( pg, 0, 0.11, gb, .7, false, frame_color, true ) );      }      if ( sel[ns].nextTextFrame  ) {        items.push( draw_rect( pg, 1, 0.89, gb, .7, false, frame_color, true ) );      }     }       items.push( draw_rect( pg, 0.8, 0, gb, 1, frame_color ) )        pg.groups.add( items );  }  doc.viewPreferences.rulerOrigin = prev_ro;  // ---------------------------------------------------------------------------------------  //  x und y sind in [0, 1] wobei 1 bedeutet: "auf rechter/unterer Kante"  //  size von 1 bedeutet 2mm Kantenlänge  //  wenn x == -1, ist gb = Eingabeparameter  // ---------------------------------------------------------------------------------------  function draw_rect( pg, x, y, gb, size, fill, stroke, is_triangle) {//		$.bp();    if ( size === undefined ) size = 1;    if ( fill === undefined ) fill = doc.swatches.item("Paper");    if ( fill === false ) fill = doc.swatches.item("None");    if ( stroke === undefined ) stroke = doc.colors.item('frame_color');    if ( is_triangle === undefined ) is_triangle = false;    var wh = 1.5 * size;    var weight = 0.25    var gbw = gb[3] - gb[1];    var gbh = gb[2] - gb[0];    var xc = gb[1] + x * gbw;    var yc = gb[0] + y * gbh;    if ( is_triangle ) {      var item = pg.polygons.add();      item.paths[0].entirePath = [         [xc - wh/2, yc- wh/2],        [xc + wh/2, yc],        [xc - wh/2, yc + wh/2]      ];    } else {      var item = pg.rectangles.add( );    }    if ( x === -1 ) {      item.geometricBounds = gb;    } else {      item.geometricBounds = [        yc - wh/2,        xc- wh/2,        yc + wh/2,        xc + wh/2      ];    }    item.strokeColor = stroke;    item.fillColor = fill;    item.strokeWeight = weight;    return item;  }}